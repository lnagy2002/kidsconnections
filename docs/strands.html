<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Word Search</title>
<style>
:root {
  --bg: #0e364b;
  --panel: #0e364b;
  --text: #a9f4f4;
  --ink: #a9f4f4;
  --muted: #f0db79;
  --border: #1b2659;
  --ok: #4ade80;
  --no: #64748b;
  --maybe: #facc15;
  --bad: #e4572e;
  --key: #0f1736;
}

.wrap { display:flex; justify-content:center; }
.container { display:flex; margin:0 auto; flex-wrap:wrap; }
.left { padding:1rem; }
.right { padding:1rem; }

.board{
  display:grid;
  gap:5px;
  justify-content:center;
  user-select:none; touch-action:none;
  cursor:pointer;
}

.cell{
  width:50px; height:50px;
  background:#0f4160;
  color:#a9f4f4;
  font-weight:600; font-size:1.3rem;
  border-radius:12px;
  display:flex; align-items:center; justify-content:center;
  cursor:pointer; transition:all .15s ease;
  box-shadow:0 1px 2px rgba(0,0,0,.3);
  user-select:none;
}

@keyframes pulse {
  0%   { transform:scale(1); box-shadow:0 0 0 #e76f51; }
  50%  { transform:scale(1.15); box-shadow:0 0 18px #e76f51aa; }
  100% { transform:scale(1.05); box-shadow:0 0 10px #e76f51aa; }
}

.cell.sel{
  background:var(--maybe);
  color:#000;
  animation:pulse .4s ease;
}
.cell.found{
  background:var(--ok)!important; color:#000;
}
/* New: if a found tile is currently selected, keep it green but show a subtle outline/pulse */
.cell.found.sel{
  outline:2px solid #fff3; animation:pulse .4s ease;
}

.list{flex:1;min-width:260px;background:var(--key);border:1px solid var(--tile-edge);border-radius:12px;padding:12px}
.list h3{margin:0 0 6px;font-size:16px;color:var(--accent)}
ul.words{list-style:none;margin:0;padding:0;}
ul.words li{break-inside:avoid;margin:4px 6px;padding:4px 6px;border-radius:6px;background:#0b3347;font-weight:600}
ul.words li.found{background:var(--no);text-decoration:line-through;color:var(--ok);}
.status{font-size:14px;color:var(--muted);text-align:center;}

@media (max-width:700px){
  .left,.right{flex:0 0 100%;}
  .cell{width:40px; height:40px; font-weight:500; font-size:1rem;}
  .board{gap:1px;}
}
</style>

<link rel="stylesheet" href="https://lnagy2002.github.io/kidsconnections/games-utils.css">
<script src="https://lnagy2002.github.io/kidsconnections/games-menu.js" defer data-menu="https://lnagy2002.github.io/kidsconnections/games-menu.json"></script>
<script src="https://lnagy2002.github.io/kidsconnections/games-utils.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KFSR46Z6C8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){ dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'G-KFSR46Z6C8');
</script>
</head>
<body>
<div class="main">
  <div>
    <script src="https://lnagy2002.github.io/kidsconnections/header.js" data-title="Word Search"></script>
  </div>

  <div class="section"></div>

  <div class="wrap">
    <div class="container">
      <div class="left"><div id="board" class="board"></div></div>
      <div class="right">
        <div class="list">
          <h3>Find These Words</h3>
          <ul id="wordList" class="words"></ul>
        </div>
      </div>
    </div>
  </div>
  <div class="status" id="status"></div>
</div>

<script>
(function(){
  // ---------- Config (levels & word banks) ----------
  const LEVELS = {
    easy:   { size: 8,  words: ["CODE","LOGIC","MIND","BRAIN","SHAPE","GRID","TILE","PATH"] },
    medium: { size: 10, words: ["ALGORITHM","PUZZLE","PATTERN","REASON","MEMORY","STRATEGY","SEARCH","CURIOUS"] },
    hard:   { size: 12, words: ["NEUROPLASTIC","DEDUCTION","CREATIVITY","SEQUENCE","SYMMETRY","CONNECT","OPTIMIZE","ITERATION","FUNCTION"] }
  };

  // 8 directions (dx,dy): N, NE, E, SE, S, SW, W, NW
  const DIRS = [ [0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1] ];

  const elBoard = document.getElementById('board');
  const elWordList = document.getElementById('wordList');
  const elStatus = document.getElementById('status');

  let grid = [], size = 10, placed = new Map(); // word -> array of {x,y}
  let found = new Set();
  let dragging = false, sel = []; // selection path of {x,y,el}
  let lockedDir = null; // direction vector once 2nd cell chosen

  function randInt(n){ return Math.floor(Math.random()*n); }
  function inBounds(x,y){ return x>=0 && y>=0 && x<size && y<size; }
  function clearStatus(msg=""){ elStatus.textContent = msg; }
  function alpha(){ return String.fromCharCode(65 + randInt(26)); }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=randInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

  // ---------- Grid generation ----------
  function newEmptyGrid(n){ return Array.from({length:n},()=>Array(n).fill(null)); }

  function canPlace(word, x, y, dx, dy, grid){
    for(let i=0;i<word.length;i++){
      const nx = x + dx*i, ny = y + dy*i;
      if(!inBounds(nx,ny)) return false;
      const cur = grid[ny][nx];
      if(cur && cur !== word[i]) return false;
    }
    return true;
  }

  function placeWord(word, grid){
    const attempts = size*size*4;
    for(let a=0;a<attempts;a++){
      const [dx,dy] = DIRS[randInt(DIRS.length)];
      const x = randInt(size), y = randInt(size);
      if(canPlace(word,x,y,dx,dy,grid)){
        const coords=[];
        for(let i=0;i<word.length;i++){
          const nx=x+dx*i, ny=y+dy*i;
          grid[ny][nx]=word[i];
          coords.push({x:nx,y:ny});
        }
        placed.set(word, coords);
        return true;
      }
    }
    return false;
  }

  function fillBlanks(grid){
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        if(!grid[y][x]) grid[y][x] = alpha();
      }
    }
  }

  function renderBoard(){
    elBoard.style.gridTemplateColumns = `repeat(${size}, max-content)`;
    elBoard.innerHTML = '';
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const div = document.createElement('div');
        div.className = 'cell';
        div.textContent = grid[y][x];
        div.dataset.x = x;
        div.dataset.y = y;
        elBoard.appendChild(div);
      }
    }
  }

  function renderList(words){
    elWordList.innerHTML = '';
    for(const w of words){
      const li = document.createElement('li');
      li.textContent = w;
      li.id = `word-${w}`;
      elWordList.appendChild(li);
    }
  }

  function markFound(word){
    const coords = placed.get(word) || [];
    for(const {x,y} of coords){
      const idx = y*size + x;
      const cell = elBoard.children[idx];
      cell.classList.remove('sel');
      cell.classList.add('found'); // persist green highlight
    }
    found.add(word);
    const li = document.getElementById(`word-${word}`);
    if(li) li.classList.add('found');
    clearStatus(found.size === placed.size ? 'ðŸŽ‰ All words found!' : `Found: ${word}`);
    if (found.size === placed.size) {
      celebrate?.(); // if you have a celebrate() elsewhere
    }
  }

  function resetSelection(){
    // Always clear the temporary selection glowâ€”even on found tiles
    for(const s of sel){ s.el.classList.remove('sel'); }
    sel = [];
    lockedDir = null;
  }

  function dirFrom(a,b){
    const dx = Math.sign(b.x - a.x);
    const dy = Math.sign(b.y - a.y);
    return [dx,dy];
  }

  function areNeighbors(a,b){
    return Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y))===1;
  }

  // Check if the selected path matches any placed word (forward or backward)
  function checkSelection(){
    if(sel.length<2){ resetSelection(); return; }
    const path = sel.map(s=>grid[s.y][s.x]).join('');
    const rpath = path.split('').reverse().join('');

    for(const [word,coords] of placed.entries()){
      if(found.has(word)) continue;
      const w1 = coords.map(c=>grid[c.y][c.x]).join('');
      const w2 = w1.split('').reverse().join('');
      const selStr = path;
      const selRev = rpath;
      if(selStr===w1 || selStr===w2 || selRev===w1 || selRev===w2){
        if(sel.length === coords.length){
          markFound(word);
          resetSelection();
          return;
        }
      }
    }
    clearStatus('Not a word. Try again.');
    resetSelection();
  }

  function handlePointerDown(e){
    const target = e.target.closest('.cell');
    if(!target) return;
    // Allow starting on found tiles (intersections)
    dragging = true; sel=[]; lockedDir=null; clearStatus('');
    addToSelection(target);
  }
  function handlePointerMove(e){
    if(!dragging) return;
    const target = document.elementFromPoint(e.clientX, e.clientY)?.closest('.cell');
    if(!target) return;
    const last = sel[sel.length-1];
    const nx = +target.dataset.x, ny = +target.dataset.y;
    if(last && last.x===nx && last.y===ny) return;
    addToSelection(target);
  }
  function handlePointerUp(){
    dragging=false; checkSelection();
  }

  function addToSelection(target){
    const x = +target.dataset.x, y = +target.dataset.y;
    const cur = {x,y,el:target};

    if(sel.length===0){
      sel.push(cur); target.classList.add('sel'); return;
    }

    const last = sel[sel.length-1];
    if(!areNeighbors(last,cur)) return; // must be adjacent

    // Lock direction after second tile
    if(sel.length===1){ lockedDir = dirFrom(last,cur); }
    else{
      const d = dirFrom(last,cur);
      if(d[0]!==lockedDir[0] || d[1]!==lockedDir[1]) return; // must stay straight
    }

    // Prevent backtracking within current selection
    if(sel.some(s=>s.x===x && s.y===y)) return;

    target.classList.add('sel');
    sel.push(cur);
  }

  // ---------- Puzzle lifecycle ----------
  function build(levelKey){
    const {size:sz, words} = LEVELS[levelKey];
    size = sz; placed.clear(); found.clear();
    grid = newEmptyGrid(size);

    const wordsUp = words.map(w=>w.toUpperCase());
    const sorted = [...wordsUp].sort((a,b)=>b.length-a.length);

    let placedCount=0;
    for(const w of sorted){ if(placeWord(w, grid)) placedCount++; }
    fillBlanks(grid);

    renderBoard();
    renderList(wordsUp);

    elBoard.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);

    clearStatus(`Placed ${placedCount}/${wordsUp.length} words.`);
  }

  // Init
  const level = getQueryParam('level') || 'easy';
  build(level);
})();
</script>
</body>
</html>
